# О чём следует позаботиться перед использованием GraphQL

## Декларирование ошибок

Перед началом работы, стоит договориться о том как будут выглядеть ошибки в API. У Graphql сейчас **нет однозначного решения** по декларированию серверных ошибок. Серверные и клиентские решения у разных команд устроены по разному, об этом стоит обеспокоится в самом начале. Будет проще, если сервер и клиент от одной команды (например Apollo server и Apollo client).

## Авторизация через заголовки

Для авторизации клиента мы все привыкли использовать заголовки запросов. В graphql для обычных запросов и мутаций используется POST, где мы можем установить свои заголовки авторизации.

Для подписок, нужен WebSocket. А у WS **использование заголовков ограничено**. При подключении к WS делается первый инициализирующий запрос, вместе с ним мы можем отправить параметры аутентификации.

## Пагинация

Некоторые сервера могут иметь ограничение длины списков. Без пагинации не обойтись, не забудьте предусмотреть её с самого начала и договориться с бэком о виде её реализации. С graphql пагинацию можно реализовать разными способами. Например привычным для REST параметром “page” с номером нужной нам страницы. Наиболее удобная и гибкая система с использованием курсоров. [https://graphql.org/learn/pagination/#pagination-and-edges](https://graphql.org/learn/pagination/#pagination-and-edges)

## GraphQL Subscribtion

Подписки - один из способов информирования клиента об изменениях произошедших на сервере.

### Протокол реализации подписок

Для GraphQL Subscription нет какого то единого [протокола](https://github.com/apollographql/apollo-client/blob/21f1faa30708b584dd672ec4abd5a814bd4d0f22/docs/source/data/subscriptions.mdx#choosing-a-subscription-library) обмена сообщениями. Это надо учитывать заранее, что бы сервер и клиент использовали один и тот же [протокол](https://github.com/apollographql/apollo-client/blob/21f1faa30708b584dd672ec4abd5a814bd4d0f22/docs/source/data/subscriptions.mdx#choosing-a-subscription-library).

### Согласованность данных и решение конфликтов

Подписки могут прийти в любой момент времени и в любом порядке, с этим связано несколько сложностей. При получении данных по подписке нужно решать как эти данные влияют на состояние приложения, куда вставляются новые элементы, если это список, или как решаются конфликты, если одни и те же данные получаются из разных источников(от пользователя и от сервера).

### Рассинхрон подписок и мутаций

Подписки работают на WebSocket, при плохом интернете WS могут отвалиться, и за время отсутствия подключения мы можем что то недополучить. Подписки это классный дополнительный функционал. Но не стоит полагаться на подписки как на основной источник данных.
Подписка работает в отдельном потоке, мы не можем точно знать, что какой то результат подписки относится к конкретной запущенной мутации. По этому мутация должна предоставить результат своей работы (например изменённое состояние объекта или его новый экземпляр).

## Apollo cache vs state management

На первый взгляд apollo cache и любой из менеджеров состояния выполняют одну и ту же задачу, хранят данные с бэка. Но работать с Apollo cache бывает очень не удобно. Не нужно стесняться использовать оба решения. Apollo только для серверных данных, менеджер состояния для состояния приложения. В менеджере состояния можно хранить ссылки на Apollo Cache.

## Vue-Apollo

Apollo Client активно развивается и может часто менять интерфейс. Версия Apollo во Vue-Apollo может сильно отставать. Есть не маленький риск встретить баги исправленные в чистом клиенте Apollo.
